# Customer address for KYC submission
type Address {
  # Descriptive combination of unit/block/house number and street name of the address
  address: String!

  # Extra descriptions about the address such as landmarks or corners
  addressDetails: String

  # City of the address
  city: String!

  # Country of the address
  country: CountryValue!

  # Postal code of the address
  postalCode: String!

  # State division of the address
  state: String!
}

# Autogenerated input type of ApproveKycMutation
input ApproveKycMutationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Expiration date for this KYC.
  #
  # Validations:
  # - Must be a future date.
  expirationDate: Date!

  # The ID of the KYC
  kycId: String!
}

# Autogenerated return type of ApproveKycMutation
type ApproveKycMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Mutation errors
  #
  # Operation Errors:
  # - KYC is not pending
  errors: [UserError!]!

  # Approved KYC
  kyc: Kyc
}

# DAO users who publish proposals and vote for them
type AuthorizedUser {
  # User's ethereum address
  address: EthAddress!

  # Date when the proposal was published
  createdAt: ISO8601DateTime!

  # Display name of the user which should be used to identify the user.
  #
  # This is just username if it is set; otherwise, this is just `user<id>`.
  displayName: String!

  # User's email
  email: String

  # User's ID
  id: ID!

  # A flag indicating the user is an KYC officer
  #
  # Privileges:
  # - Can approve or reject KYCs
  isKycOfficer: Boolean!

  # Current KYC submission of the user
  kyc: Kyc

  # User's username
  username: String
}

# Autogenerated input type of ChangeEmailMutation
input ChangeEmailMutationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # New email for the user.
  #
  # Validations:
  # - Maximum of 254 characters
  # - Must be of this format: `<name_part>@<domain_part>`
  email: String!
}

# Autogenerated return type of ChangeEmailMutation
type ChangeEmailMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Mutation errors
  errors: [UserError!]!

  # User with the updated email
  user: AuthorizedUser
}

# Autogenerated input type of ChangeUsernameMutation
input ChangeUsernameMutationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Username for the user.
  #
  # Validations:
  # - Minimum of 2 characters
  # - Maximum of 150 characters
  # - Alphanumerical characters plus underscore
  # - Must not start with `user`
  username: String!
}

# Autogenerated return type of ChangeUsernameMutation
type ChangeUsernameMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Mutation errors
  #
  # Operation Errors:
  # - Username is already set
  errors: [UserError!]!

  # User with the updated email
  user: AuthorizedUser
}

# Comments/messages between voters for proposals
type Comment {
  # Message/body of the comment.
  #  This is `null` if this message is deleted.
  body: String

  # Date when the comment was published
  createdAt: ISO8601DateTime!

  # Comment ID
  id: ID!

  # A flag to indicate if the current user liked this comment
  liked: Boolean!

  # Number of user who liked this comment
  likes: Int!

  # Parent id of the comment
  parentId: String!

  # Replies/comments about this comment
  replies(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CommentConnection!

  # Stage/phase the comment was published
  stage: Stage!

  # Poster of this comment
  user: User!
}

# The connection type for Comment.
type CommentConnection {
  # A list of edges.
  edges: [CommentEdge]

  # A list of nodes.
  nodes: [Comment]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type CommentEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Comment
}

# Country for KYC Registration
type Country {
  # A flag if the country is blocked
  blocked: Boolean!

  # Name of the country
  name: String!

  # App value of the country
  value: String!
}

# A country represented by a string that comes form `Country.value`
scalar CountryValue

# A base64-encoded data URL (`data:image/png;base64;...`)
# represented as a object with data and file type but no filename
scalar DataUrl

# A date represented as a YYYY-MM-DD or iso8601 date
scalar Date

# Customer's employment status
enum EmploymentStatusEnum {
  # Works for a company
  EMPLOYED

  # Works as a freelancer
  SELF_EMPLOYED

  # Doesn't work for money
  UNEMPLOYED
}

# The user's eth address represented by a `String`
scalar EthAddress

# Customer's gender be it male or female
enum GenderEnum {
  # To be voted on
  FEMALE

  # To be endorsed by a moderator
  MALE
}

# An ISO 8601-encoded datetime
scalar ISO8601DateTime

# Customer ID pose for KYC submission
type IdentificationPose {
  # Image of the pose with the ID
  #
  #
  # It is possible for this to be `null` after submitting
  # since file storage is asynchronous, so be careful with the mutation.
  # Howver, it should be a valid object in practice.
  image: Image

  # Verification code for the pose
  verificationCode: String!
}

# Customer identification proof for KYC submission
type IdentificationProof {
  # Expiration date of the ID
  expirationDate: Date!

  # Image of the ID.
  #
  # It is possible for this to be `null` after submitting
  # since file storage is asynchronous, so be careful with the mutation.
  # Howver, it should be a valid object in practice.
  image: Image

  # Designated code/number for the ID
  number: String!

  # Type of ID used
  type: IdentificationProofTypeEnum!
}

# Customer's ID proof type
enum IdentificationProofTypeEnum {
  # National Identity Card (Drivers License not accepted)
  IDENTITY_CARD

  # National ID Card(Singapore Residents only)
  NATIONAL_ID

  # International passport
  PASSPORT
}

# Image used for KYC such as jpegs or pngs
type Image {
  # Content type of the image such as `application/png`
  contentType: String!

  # Base64 encoded string for the data itself
  dataUrl: String!

  # File size of the image in bytes
  fileSize: Int!

  # File name of the image
  filename: String!
}

# Employment income ranges for KYC
type IncomeRange {
  # Descriptive value of the income range
  range: String!

  # Value of the income range
  value: String!
}

# Income ranges represented by a string that comes form `IncomeRange.value`
scalar IncomeRangeValue

# Employment industry for KYC
type Industry {
  # Name of the industry
  name: String!

  # Value of the industry
  value: String!
}

# Industry for KYC submission
scalar IndustryValue

# A customer's KYC submission
type Kyc {
  # Birth date of the customer
  birthdate: Date!

  # Date when the KYC was submitted
  createdAt: ISO8601DateTime!

  # Customer email
  email: String!

  # Current employment industry of the customer
  employmentIndustry: IndustryValue!

  # Current employment status of the customer
  employmentStatus: EmploymentStatusEnum!

  # Customer ethereum address
  ethAddress: EthAddress!

  # Expiration date of the KYC.
  #
  # After this date, the KYC is marked `EXPIRED`
  # and the user should submit again.
  expirationDate: Date

  # First name of the customer
  firstName: String!

  # Gender of the customer
  gender: GenderEnum!

  # KYC ID
  id: ID!

  # Pose image where the customer is holding an ID
  identificationPose: IdentificationPose!

  # ID image such as passport or national ID of the customer
  identificationProof: IdentificationProof!

  # Income range per annum of the customer
  incomeRange: IncomeRangeValue!

  # A list of IP addresses used by the customer.
  #
  # Currently, IP address is not tracked so this is an empty list.
  ipAddresses: [String!]!

  # A flag if the kyc is `APPROVED`
  isApproved: Boolean!

  # Last name of the customer
  lastName: String!

  # Country of the customer's nationality
  nationality: CountryValue!

  # Phone number of the customer including the country code
  phoneNumber: String!

  # If the status is `REJECTED`, this is reason it was rejected.
  rejectionReason: RejectionReasonValue

  # Residential proof such as utility bills of the customer
  residenceProof: ResidenceProof!

  # Current status or state of the KYC.
  #
  # If the KYC is approved and it is after the expiration date,
  #  the status is expired.
  status: KycStatusEnum!

  # Date when the KYC was last touched or modified
  updatedAt: ISO8601DateTime!

  # Customer user ID
  userId: String!
}

# An edge in a connection.
type KycEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Kyc
}

# Page-based pagination container for KYCs.
#
# Note: AVOID USING `pageInfo` since it does nothing and not easily customized at the moment.
# Instead, use `hasNextPage` and `hasPreviousPage` from this object instead.
type KycPaginatedConnection {
  # A list of edges.
  edges: [KycEdge]

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When backwards forwards, are there more items?
  hasPreviousPage: Boolean!

  # A list of nodes.
  nodes: [Kyc]

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # Total number of records for this collection
  totalCount: Int!

  # Total number of pages for this collection relative to page size
  totalPage: Int!
}

# Kyc stages or phases
enum KycStatusEnum {
  # Kyc is approved
  APPROVED

  # Kyc expired and user must resubmit
  EXPIRED

  # Kyc still pending or waiting to be approved
  PENDING

  # Kyc was rejected
  REJECTED
}

# This is just `CountryValue` but must be from a legal country
#
# Blocked countries:
# - Belarus
# - Cuba
# - Democratic Republic of the Congo
# - Iran
# - Iraq
# - Ivory Coast
# - Liberia
# - Myanmar
# - North Korea
# - South Sudan
# - United States
# - Zimbabwe
scalar LegalCountryValue

# Voting rounds for proposal voting
type Milestone {
  # Description of the milestone
  description: String!

  # Title of the milestone
  title: String!
}

type Mutation {
  # As a KYC officer, approve a pending KYC.
  #
  # Role: KYC Officer
  approveKyc(input: ApproveKycMutationInput!): ApproveKycMutationPayload

  # Change the current user's email
  changeEmail(input: ChangeEmailMutationInput!): ChangeEmailMutationPayload

  # Set the current user's username.
  #
  # Username can only be changed ONCE so caution with this operation.
  changeUsername(input: ChangeUsernameMutationInput!): ChangeUsernameMutationPayload

  # As a KYC officer, reject a pending KYC with a reason.
  #
  # Role: KYC Officer
  rejectKyc(input: RejectKycMutationInput!): RejectKycMutationPayload

  # As the current user, submit a KYC to access more features of the app.
  #
  # To submit the KYC, the user must already have his email set.
  # Once submitted, a KYC admin will check the facts and
  #  will either approve or reject it.
  # If rejected with a reason or expired over time,
  #  the user is encouraged to submit another KYC through this operation.
  submitKyc(input: SubmitKycMutationInput!): SubmitKycMutationPayload
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

# A positive integer taken from the `Integer` implementation
scalar PositiveInteger

# DAO proposals/projects to be voted and funded for
type Proposal {
  # Root comment id of the proposal
  commentId: String!

  # Date when the proposal was published
  createdAt: ISO8601DateTime!

  # Current voting round for this proposal
  currentVotingRound: VotingRound

  # Proposal's short description
  description: String!

  # Proposal's longer description or details
  details: String!

  # A flag to indicate if the current user liked this proposal
  liked: Boolean!

  # Number of user who liked this proposal
  likes: Int!

  # Milestones for this proposal
  milestones: [Milestone!]!

  # Eth contract address of the proposal
  proposalId: String!

  # Publisher of this proposal
  proposer: User!

  # Stage/phase the proposal is in
  stage: Stage!

  # Proposal's title
  title: String!

  # Total funding for the proposal
  totalFunding: String!

  # Current voting stage of this proposal
  votingStage: VotingStage
}

type Query {
  # Proposals
  commentThreads(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Search comment replies by its id.
    #  This is required or proposal id.
    commentId: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Search proposal threads by proposal id address.
    #  This is required or the comment id.
    # Also this takes precedence if both exists.
    proposalId: String

    # Sorting options for the threads
    sortBy: ThreadSortBy = LATEST

    # Filter comments by stage/phase.
    #  If not specified, it defaults to the current stage.
    stage: Stage
  ): CommentConnection!

  # List of countries to determine nationality for KYC
  countries(
    # Filter countries if they are blocked.
    #
    # By default, this returns the usable countries for the frontend.
    blocked: Boolean = false
  ): [Country!]!

  # Get the current user's information
  currentUser: AuthorizedUser

  # List of income ranges for KYC
  incomeRanges: [IncomeRange!]!

  # List of industries for KYC
  industries: [Industry!]!

  # Search for proposals/projects
  proposals(
    # Filter proposals if it is liked or not by the current user
    liked: Boolean

    # Filter proposals by a list of proposal id addresses
    proposalIds: [String!]

    # Sorting options for the proposals
    sortBy: SortBy = DESC

    # Filter proposals by its stage/phase
    stage: Stage
  ): [Proposal!]!

  # List of rejection reasons for KYC rejection
  rejectionReasons: [RejectionReason!]!

  # Search for KYCs, pending or all
  #
  # Role: KYC Officer
  searchKycs(
    # Batch page number for the collection.
    #
    # If the page number exceeds the total count
    # then it returns an empty data
    page: PositiveInteger = 1

    # Number of records to fetch per page
    pageSize: PositiveInteger = 30

    # Filter KYCs by their status
    status: KycStatusEnum
  ): KycPaginatedConnection!

  # Find a specific user.
  #
  # Role: KYC Officer
  user(
    # Search user by their ID
    id: String!
  ): AuthorizedUser
}

# Autogenerated input type of RejectKycMutation
input RejectKycMutationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the KYC
  kycId: String!

  # Reason for rejecting the KYC
  rejectionReason: RejectionReasonValue!
}

# Autogenerated return type of RejectKycMutation
type RejectKycMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Mutation errors
  #
  # Operation Errors:
  # - KYC is not pending
  errors: [UserError!]!

  # Rejected KYC
  kyc: Kyc
}

# Reasons for rejecting a KYC
type RejectionReason {
  # Descriptive name of the reason
  name: String!

  # Value of the reason
  value: String!
}

# A rejection rason represented by a string that comes form `RejectionReason.value`
scalar RejectionReasonValue

# Customer residence proof for KYC submission
type ResidenceProof {
  # Image of the residence proof.
  #
  # It is possible for this to be `null` after submitting
  # since file storage is asynchronous, so be careful with the mutation.
  # Howver, it should be a valid object in practice.
  image: Image

  # Current residential address of the customer
  residence: Address!

  # Kind of image presented as proof
  type: ResidenceProofTypeEnum!
}

# Type of customer residence proof
enum ResidenceProofTypeEnum {
  # Bank statement
  BANK_STATEMENT

  # Utility bill such as electricity or water
  UTILITY_BILL
}

enum SortBy {
  # Sort in ascending creation time
  ASC

  # Sort in descending creation time
  DESC
}

# Phases or stages for a proposal or comment
enum Stage {
  # Closed, finished or rejected
  ARCHIVED

  # To be voted on
  DRAFT

  # To be endorsed by a moderator
  IDEA
}

# Autogenerated input type of SubmitKycMutation
input SubmitKycMutationInput {
  # Descriptive combination of unit/block/house number and street name of the customer.
  #
  # Validations:
  # - Maximum of 1000 characters
  address: String!

  # Extra descriptions about the address such as landmarks or corners.
  #
  # Validations:
  # - Maximum of 1000 characters
  addressDetails: String

  # Legal/non-blocked country of the customer's birth
  birthCountry: LegalCountryValue!

  # Birth date of the customer.
  #
  # Validations:
  # - Must be 18 years or older
  birthdate: Date!

  # City address of the customer.
  #
  # Validations:
  # - Maximum of 250 characters
  city: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Country address of the customer
  country: LegalCountryValue!

  # Current employment industry of the customer
  employmentIndustry: IndustryValue!

  # Current employment status of the customer
  employmentStatus: EmploymentStatusEnum!

  # First name of the customer.
  #
  # Validations:
  # - Maximum of 150 characters
  firstName: String!

  # Gender of the customer
  gender: GenderEnum!

  # Image data URL to prove identification is valid
  #
  # Validations:
  # - Maximum of 10 MB size
  # - JPEG or PNG files only
  identificationPoseDataUrl: DataUrl!

  # The verification code presented in the identification pose.
  #
  # It is comprised of `<block number>-<first two digits of the block hash>`-<last two of the hash>`
  #
  # Validations:
  # - Block number be 20 blocks old
  identificationPoseVerificationCode: String!

  # Image data URL to prove personal identification.
  #
  # Validations:
  # - Maximum of 10 MB size
  # - JPEG or PNG files only
  identificationProofDataUrl: DataUrl!

  # Expiration date of the ID.
  #
  # Validations:
  # - Must not be expired or a future date
  identificationProofExpirationDate: Date!

  # Code/number of the ID.
  #
  # Validations:
  # - Maximum of 50 characters
  identificationProofNumber: String!

  # Type of ID used
  identificationProofType: IdentificationProofTypeEnum!

  # Income range per annum of the customer
  incomeRange: IncomeRangeValue!

  # First name of the customer.
  #
  # Validations:
  # - Maximum of 150 characters
  lastName: String!

  # Country of the customer's nationality
  nationality: LegalCountryValue!

  # Phone number of the customer including the country code.
  #
  # Validations:
  # - Maximum of 20 characters
  # - Can optionally start with `+`
  # - Must be comprised of digits (`0-9`) or dashes (`-`)
  # - Must not start or end with a dash
  phoneNumber: String!

  # Postal code address of the customer.
  #
  # Validations:
  # - Maximum of 12 characters
  # - Must be comprised of alphanumeric characters (`A-Z0-9`), spaces and dashes (`-`)
  # - Must not end or begin with a dash
  postalCode: String!

  # Image data URL to prove personal residence
  #
  # Validations:
  # - Maximum of 10 MB size
  # - JPEG or PNG files only
  residenceProofDataUrl: DataUrl!

  # Kind/type of proof presented for residence
  residenceProofType: ResidenceProofTypeEnum!

  # State or division addressof the customer.
  #
  # Validations:
  # - Maximum of 250 characters
  state: String!
}

# Autogenerated return type of SubmitKycMutation
type SubmitKycMutationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Mutation errors
  #
  # Operation Errors:
  # - Email not sent
  # - Already have a pending or active KYC
  errors: [UserError!]!

  # New kyc submission
  kyc: Kyc
}

enum ThreadSortBy {
  # Sort in descending creation time
  LATEST

  # Sort in ascending creation time
  OLDEST
}

# DAO users who publish proposals and vote for them
type User {
  # Display name of the user which should be used to identify the user.
  #
  # This is just username if it is set; otherwise, this is just `user<id>`.
  displayName: String!
}

# A user-readable error
type UserError {
  # Which input final value this error came from
  field: String

  # A description of the error
  message: String!
}

# Voting rounds for proposal voting
type VotingRound {
  # Commit stage deadline
  commitDeadline: String

  # Stacked DGXs that were voted voted no
  no: String!

  # Reveal stage deadline
  revealDeadline: String

  # The total number of voters for this round
  totalVoterCount: String!

  # The total number of stake for this round
  totalVoterStake: String!

  # Draft voting stage deadline
  votingDeadline: String

  # Stacked DGXs that were voted voted yes
  yes: String!
}

# Phases for a voting round
enum VotingStage {
  # Voters commit to a vote
  COMMIT

  # The proposal is being drafted or finalized
  DRAFT

  # Voters reveal their vote
  REVEAL
}